name: Docker-CI

on:
  push:
    branches: [docker]
  pull_request:
    types: [opened, edited, synchronize, reopened, ready_for_review]
    branches: [docker]

jobs:
  build-frontend-app:
    concurrency: 
      group: docker_ci-${{ github.event.pull_request.number || github.ref }}
      cancel-in-progress: true
    runs-on: ubuntu-latest
    permissions:
      actions: write # necessary to overwrite the cache
    steps:
      - name: Checkout source code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set up Docker
        uses: docker-practice/actions-setup-docker@fd7ecdac7caf8e2c541a48c9bcc280aae59a8461 # master

      - name: Restore cache
        uses: actions/cache/restore@v3
        id: RestoreCache
        with:
          path: .cargo-target
          key: docker-cargo-cache_${{ runner.os }}

      - name: Build the app
        id: Build
        run: |
          # set up the cache
          mkdir -p .cargo-target

          cd frontend/scripts/docker-buildfiles

          sed -i \
            -e 's|^#CI-CACHE-INJECT-MARKER:.*|ARG cargo_target_parent=/appflowy|' \
            -e 's|^#CI-CACHE-RETRIEVE-MARKER:.*|COPY --from=builder /appflowy/.cargo-target /cargo-cache|' \
            Dockerfile
          cat Dockerfile

          uid="$(id -u)"
          gid="$(id -g)"
          echo "BUILD_UID=$uid" >> "$GITHUB_ENV"
          echo "BUILD_GID=$gid" >> "$GITHUB_ENV"

          # uses the format which `find -newerat $date` wants
          echo "APP_BUILD_START_TIME=$(date -u '+%Y-%m-%d %H:%M:%S')" >> "$GITHUB_ENV"

          docker-compose build \
            --build-arg "uid=$uid" \
            --build-arg "gid=$gid" \
            --progress=plain \
          | while read line; do \
              if [[ "$line" =~ ^Step[[:space:]] ]]; then \
                echo "$(date -u '+%H:%m:%S') | $line"; \
              else \
                echo "$line"; \
              fi; \
            done \

          # clear the current cache to free up space because it has already been
          # used in the build and a new one can be extracted from the
          # newly-built image
          rm -rf .cargo-target

      - name: Retrieve build cache
        id: RetrieveBuildCache
        if: ${{ github.ref == 'refs/heads/docker' && steps.Build.outcome == 'success' }}
        run: |
          # fetch build artifacts from the Docker image
          mkdir .tmp
          chown "$BUILD_UID:$BUILD_GID" .tmp
          docker run --rm \
            -v "$PWD"/.tmp:/cache \
            --entrypoint cp appflowy/appflowy:latest -r --preserve=mode,timestamps /cargo-cache /cache
          mv .tmp/cargo-cache .cargo-target
          rm -rf .tmp

          # clean up stale build artifacts
          # artifacts are deemed stale if they were not accessed in the last build
          find .cargo-target -type f -not -newerat "$APP_BUILD_START_TIME" -delete -print

      # delete the cache so that it can be updated in the following step
      # workaround for https://github.com/actions/cache/issues/342
      # workaround for https://github.com/actions/cache/issues/171
      - name: Allow for overwriting the current cache
        if: ${{
                github.ref == 'refs/heads/docker' &&
                steps.Build.outcome == 'success' &&
                steps.RetrieveBuildCache.outcome == 'success' &&
                steps.RestoreCache.outputs.cache-hit
             }}
        continue-on-error: true
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          gh extension install actions/gh-actions-cache
          gh actions-cache delete --confirm ${{ steps.RestoreCache.outputs.cache-primary-key }}

      - name: Update the cache
        if: ${{
                github.ref == 'refs/heads/docker' &&
                steps.Build.outcome == 'success' &&
                steps.RetrieveBuildCache.outcome == 'success'
             }}
        uses: actions/cache/save@v3
        with:
          path: .cargo-target
          key: ${{ steps.RestoreCache.outputs.cache-primary-key }}
